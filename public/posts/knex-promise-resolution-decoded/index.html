<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta http-equiv="x-ua-compatible" content="ie=edge">
		<link rel="alternate" type="application/rss+xml" href="/rss.xml">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="description" content="Welcome to my Blog. Here I write about dev topics.">
		<title>Knex.js promise resolution decoded</title>
		<link rel="stylesheet" href="/css/style.css"/>
		
		<script type="text/javascript">
			navigator
				.serviceWorker
				.getRegistrations()
				.then((registrations) => {
					if (!registrations && registrations.length === 0) {
						return;
					}
					for (let registration of registrations) {
						registration.unregister()
					}
				})
		</script>
	</head>
	<body class="no-grid">
		
	<a href="/" class="link-button post-home-link">All Posts</a>

		<main class="content">
			
    <article class="post-detail">

        <header class="page-header length-optimal">
            <h1 class="post-title">Knex.js promise resolution decoded</h1>
        </header>

        <p>This blog posts tackle a small but important detail in the Knex.js <code>QueryBuilder</code> interface. Misused, it can provide race conditions and unexpected behavior while communicating with the database.</p>
<h2 id="the-issue" tabindex="-1"><a class="header-anchor" href="#the-issue">The issue</a></h2>
<p>Given the following DAO:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">const</span> fooDAO <span class="token operator">=</span> <span class="token punctuation">{</span><br>  <span class="token keyword">delete</span><span class="token operator">:</span> <span class="token punctuation">(</span>pg<span class="token operator">:</span> Knex<span class="token punctuation">,</span> itemId<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">></span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> <span class="token keyword">await</span> pg<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">table</span><span class="token generic class-name"><span class="token operator">&lt;</span>Foo<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">where</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">,</span> itemId<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br><br>  insert<span class="token operator">:</span> <span class="token keyword">async</span> <span class="token punctuation">(</span>pg<span class="token operator">:</span> Knex<span class="token punctuation">,</span> item<span class="token operator">:</span> FooUpdate<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>Foo<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> pg<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">table</span><span class="token generic class-name"><span class="token operator">&lt;</span>Foo<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">returning</span><span class="token punctuation">(</span><span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>Let's walk through the differences of both functions? The first returns a <code>Promise</code> object, and the query is executed against the database. The second function instead returns a <code>QueryBuilder</code> object, even though, the typing states, it returns a <code>Promise&lt;number&gt;</code>. In this case, the query is not executed directly.</p>
<p>You might argue, why is the compiler not complaining, as the typing is obviously wrong, and why does it have different behavior?</p>
<h3 id="the-typing" tabindex="-1"><a class="header-anchor" href="#the-typing">The typing</a></h3>
<p>The compiler is not complaining because of the <a href="https://promisesaplus.com/#requirements">Promise/A+</a> definition. This definition states, that an <code>Object</code> is a <code>Promise</code> as long as a <code>then</code> method is implemented. Checking the typing or <a href="http://knexjs.org/guide/interfaces.html#promises">documentation</a> of the <code>QueryBuilder</code> interface, you can see that it defines a <code>then</code> method. Therefore, it is treated as <code>Promise</code> during type checks.</p>
<p>This misleading typing can result in race conditions or unexpected state within your application, as if you mix this up within your DAOs, your queries will not be executed in the order you might think. Once the query is executed after calling the method and for the second it depends on usage in your application. But why?</p>
<h3 id="the-different-behavior" tabindex="-1"><a class="header-anchor" href="#the-different-behavior">The different behavior</a></h3>
<p>You must know that, Knex.js only <em>executes</em> the query, by calling the <code>then</code> method and turns the <code>QueryBuilder</code> object into a <code>Promise</code>, by doing real network I/O to execute the query on the database and retrieve the data.</p>
<p>Let's take a closer look at the functions and understand, where the different behavior comes from. The first function uses <code>await</code> in front of the <code>QueryBuilder</code> creation, which implicitly calls the <code>then</code> method of the following <code>Promise</code> or object. Therefore, it is handy, that the <code>QueryBuilder</code> implements the same interface as <code>Promise</code> because you just can use <code>await</code> or <code>then</code> directly on the <code>QueryBuilder</code> and retrieve a Promise with the result or error. The second function just returns the created <code>QueryBuilder</code> object, which does not result in any query execution while calling the function itself.</p>
<p>Assume the following usage (might not be a real usage, but it helps to make it aware).</p>
<pre class="language-typescript"><code class="language-typescript">  <span class="token keyword">const</span> <span class="token function-variable function">doSomething</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token comment">//...</span><br>    fooDAO<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> <span class="token punctuation">{</span>id<span class="token operator">:</span> <span class="token string">'fooId'</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">'HelloWorld'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token comment">// do other stuff</span><br>    fooDAO<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">'fooId'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token comment">//...</span><br>  <span class="token punctuation">}</span></code></pre>
<p>In this example usage, the developer just calls the DAO functions to add the item, but is not interested to wait for the result. Then some stuff is going on and at some point the delete function is called to remove the item again, but it is not waited for that. This usage of a &quot;correct&quot; typed DAO (at least the compiler is not complaining) would result in a broken state because the item would never be deleted, as the <code>then</code> method of the returned <code>QueryBuilder</code> is never called.</p>
<h2 id="the-correct-typing" tabindex="-1"><a class="header-anchor" href="#the-correct-typing">The correct typing</a></h2>
<p>Let's write the DAO with the correct typing, which indicates the differences of the two functions directly:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">const</span> fooDAO <span class="token operator">=</span> <span class="token punctuation">{</span><br>  <span class="token keyword">delete</span><span class="token operator">:</span> <span class="token punctuation">(</span>pg<span class="token operator">:</span> Knex<span class="token punctuation">,</span> itemId<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">></span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> <span class="token keyword">await</span> pg<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">table</span><span class="token generic class-name"><span class="token operator">&lt;</span>Foo<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">where</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">,</span> itemId<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br><br>  insert<span class="token operator">:</span> <span class="token keyword">async</span> <span class="token punctuation">(</span>pg<span class="token operator">:</span> Knex<span class="token punctuation">,</span> item<span class="token operator">:</span> FooUpdate<span class="token punctuation">)</span><span class="token operator">:</span> QueryBuilder<span class="token operator">&lt;</span>Foo<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> pg<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">table</span><span class="token generic class-name"><span class="token operator">&lt;</span>Foo<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">returning</span><span class="token punctuation">(</span><span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>This improved typing now really indicates the developer, what she retrieves from the DAO function. In the first case you get a <code>QueryBuilder</code> and in the second a <code>Promise</code> which resolves in data.<br>
It might help to prevent issues like described above, but is still not a nice interface and usage for the DAO, isn't it?</p>
<p>Let's transform the DAO to have a nice interface and user experience.</p>
<h2 id="the-better-way" tabindex="-1"><a class="header-anchor" href="#the-better-way">The better way</a></h2>
<p>This section is named &quot;The better way&quot; on purpose because I do not want to state it is the right and one and only way, but I would argue it is the better than returning a <code>QueryBuilder</code> within DAO functions.<br>
As you might already think, the recommendation is, to always return a real <code>Promise</code> and not <code>QueryBuilder</code> objects.</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">const</span> fooDAO <span class="token operator">=</span> <span class="token punctuation">{</span><br>  <span class="token keyword">delete</span><span class="token operator">:</span> <span class="token punctuation">(</span>pg<span class="token operator">:</span> Knex<span class="token punctuation">,</span> itemId<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">></span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> <span class="token keyword">await</span> pg<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">table</span><span class="token generic class-name"><span class="token operator">&lt;</span>Foo<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">where</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">,</span> itemId<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br><br>  insert<span class="token operator">:</span> <span class="token keyword">async</span> <span class="token punctuation">(</span>pg<span class="token operator">:</span> Knex<span class="token punctuation">,</span> item<span class="token operator">:</span> FooUpdate<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>Foo<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> <span class="token keyword">await</span> pg<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">table</span><span class="token generic class-name"><span class="token operator">&lt;</span>Foo<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">returning</span><span class="token punctuation">(</span><span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>This fixed DAO always ensures, that the queries are really being executed on function call and return a <code>Promise</code> which can be handled properly.<br>
DAOs should always return data and encapsulate the database queries, and not leak them to the outside. This makes the interface much more simple and easy to understand or use.</p>
<h2 id="conclusion" tabindex="-1"><a class="header-anchor" href="#conclusion">Conclusion</a></h2>
<p>Typescript helps a lot in preventing you from introducing bugs, but it is not the silver bullet for everything. There might be other libraries or functions having similar typing in place, therefore always understand the libraries you use.<br>
For Knex.js, be aware of the typing issue with the <code>QueryBuilder</code> and <code>Promise</code> object, to prevent unexpected behavior. Nevertheless, it is the better way to implement DAOs in a way encapsulating the queries and only return data within a <em>Promise</em>.</p>


        <em class="post-publish-date">Published 27 Jul 2022</em>

    </article>

    
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "headline": "Knex.js promise resolution decoded",
        "author": {
            "@type": "Person",
            "name": "Nikolas Rist"
        },
        "datePublished": "2022-07-27",
        "dateModified": "2022-07-27"
    }
    </script>


		</main>
	</body>
</html>