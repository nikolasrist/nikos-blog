<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta http-equiv="x-ua-compatible" content="ie=edge">
		<link rel="alternate" type="application/rss+xml" href="/rss.xml">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="description" content="Welcome to my Blog. Here I write about dev topics.">
		<title>Microservice testing series</title>
		<link rel="stylesheet" href="/css/style.css"/>
		
		<script type="text/javascript">
			navigator
				.serviceWorker
				.getRegistrations()
				.then((registrations) => {
					if (!registrations && registrations.length === 0) {
						return;
					}
					for (let registration of registrations) {
						registration.unregister()
					}
				})
		</script>
	</head>
	<body class="no-grid">
		
	<a href="/" class="link-button post-home-link">All Posts</a>

		<main class="content">
			
    <article class="post-detail">

        <header class="page-header length-optimal">
            <h1 class="post-title">Microservice testing series</h1>
        </header>

        <h2 id="test-pyramid" tabindex="-1"><a class="header-anchor" href="#test-pyramid">TestPyramid</a></h2>
<p>The TestPyramid example, by <a href="https://martinfowler.com/bliki/TestPyramid.html">Martin Fowler</a>, is a visual supportive tool to get an idea of the distribution of your number of tests in the different levels of abstraction. It indicates to have much more low-level unit tests in contrast to high level BroadStackTests.</p>
<h2 id="tl-dr" tabindex="-1"><a class="header-anchor" href="#tl-dr">TL;DR</a></h2>
<p>The TestPyramid by <a href="https://martinfowler.com/bliki/TestPyramid.html">Martin Fowler</a> differentiates between three levels.</p>
<ol>
<li>End-to-end tests, these are:<br>
a. more error-prone as they can easily break by changes to the UI<br>
b. expensive to write<br>
c. exposed more often to non-determinism problems (or flakiness) (sometimes succeed, or fail)</li>
<li>Layer in-between, <a href="https://martinfowler.com/bliki/SubcutaneousTest.html">Subcutaneous Tests</a> (component tests) testing complex logic on an API layer and not the UI itself.</li>
<li>Unit tests, the low-level tests testing a single functionality (unit) of the service.</li>
</ol>
<h2 id="broad-stack-tests" tabindex="-1"><a class="header-anchor" href="#broad-stack-tests">BroadStackTests</a></h2>
<p><a href="https://martinfowler.com/bliki/BroadStackTest.html">BroadStackTests</a> are introduced by Martin Fowler, and put together end-to-end (e2e) tests or so-called full-stack tests. In the end all are very similar but have different names. BroadStackTests are high level (e2e) UI tests. These might be recorded using tools like <em>Selenium</em> or, even worse, done manually. They can be written in code using libraries or implement them on your own. Nowadays, you can run them with Chrome Headless within your CI/CD pipeline. They are discussed a lot, and from my point of view they are too expensive for a CI/CD pipeline. Expensive in terms of duration and implementation complexity.</p>
<p>A deeper argumentation, why not to use e2e tests, you can find in this <a href="https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html">Google blog post</a>. As of today, the <a href="https://testing-library.com/docs/">testing library</a>, provides you many possibilities to test different frontend frameworks in a user-centric way. This library allows you to mimic the usage of your components by a user. This is still faster than e2e tests and well scoped around your component.</p>
<h2 id="component-tests" tabindex="-1"><a class="header-anchor" href="#component-tests">Component Tests</a></h2>
<p>Component tests are the next level of tests which are scoped to the service they test. They are easier to write, as you might use the direct API to call the service and test the service isolated, instead of using a BroadStackTest via the UI.</p>
<p>More details about component tests can be found <a href="https://martinfowler.com/bliki/ComponentTest.html">here</a> and in the slides of Toby Clemson <a href="https://martinfowler.com/articles/microservice-testing/#testing-component-introduction">here</a></p>
<h2 id="integration-tests" tabindex="-1"><a class="header-anchor" href="#integration-tests">Integration Tests</a></h2>
<p>Integration tests are the second smallest and scoped test level in the pyramid. They test a set of modules working together and therefore scope on a sub-system of the service. More information you can find in the <a href="https://martinfowler.com/articles/microservice-testing/#testing-integration-introduction">slides</a> of Toby Clemson.</p>
<h2 id="unit-tests" tabindex="-1"><a class="header-anchor" href="#unit-tests">Unit Tests</a></h2>
<p>Unit tests are the smallest piece of tests in the TestPyramid. They are narrowed down to a single functionality and have the smallest scope. You differentiate between <em>Sociable unit testing</em> and <em>Solitary unit testing</em>. <em>Sociable</em> tests test the object through the interface and include dependencies. <em>Solitary</em> tests isolate the object and test the communication to dependencies, which are replaced by mocks. A detailed introduction about unit tests you can find again in Toby Clemson's <a href="https://martinfowler.com/articles/microservice-testing/#testing-unit-introduction">slide deck</a>.</p>
<h2 id="conclusion" tabindex="-1"><a class="header-anchor" href="#conclusion">Conclusion</a></h2>
<p>Now we know the general terms of different test types, which we will take a closer look at. The TestPyramid provides a visualization, how to distribute your number of tests. It does not help how to decide, which test is worth it and which not.</p>
<p>Throughout this series, I will provide some examples and best practices we within my team during implementing a NodeJS backend service, but the field of testing is much broader and has a lot more topics to come up with, which cannot be captured throughout this series. I'll try to provide additional resources for further reading.</p>


        <em class="post-publish-date">Published 09 Aug 2022</em>

    </article>

    
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "headline": "Microservice testing series",
        "author": {
            "@type": "Person",
            "name": "Nikolas Rist"
        },
        "datePublished": "2022-08-09",
        "dateModified": "2022-08-09"
    }
    </script>


		</main>
	</body>
</html>